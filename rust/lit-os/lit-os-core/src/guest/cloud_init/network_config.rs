use std::collections::HashMap;
use std::fs;
use std::net::IpAddr;
use std::path::Path;
use std::result::Result as StdResult;
use std::str::FromStr;

use ipnet::IpNet;
use serde::{Deserialize, Serialize};

use lit_core::utils::option::bool_option_to_bool;

use crate::error::{config_err, generic_err, io_err, serializer_err, validation_err, Result};
use crate::utils::ip::IpKind;

pub const NET_IF_ENP0S2: &str = "enp0s2";
pub const NET_IF_ENP0S3: &str = "enp0s3";
pub const NET_IF_INTERNAL: &str = NET_IF_ENP0S2;
pub const NET_IF_EXTERNAL: &str = NET_IF_ENP0S3;

pub const ALLOWED_NET_IF: [&str; 2] = [NET_IF_ENP0S2, NET_IF_ENP0S3];

#[derive(Debug, Clone, PartialEq)]
enum IfaceKind {
    Internal,
    External,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields, rename_all = "kebab-case")]
pub struct CloudInitNetworkConfig {
    version: u32,
    ethernets: HashMap<String, EthernetEntry>,
}

impl CloudInitNetworkConfig {
    // Accessors
    pub fn version(&self) -> u32 {
        self.version
    }

    pub fn ethernets(&self) -> &HashMap<String, EthernetEntry> {
        &self.ethernets
    }

    // Verify
    pub fn verify(&self) -> Result<()> {
        if self.version != 2 {
            return Err(validation_err(
                format!("invalid version for network-config: {}", self.version),
                None,
            ));
        }

        // Build allowed
        let mut allowed_if: HashMap<String, bool> = HashMap::new();

        for iface in ALLOWED_NET_IF {
            allowed_if.insert(iface.to_string(), true);
        }

        for (iface, entry) in self.ethernets.iter() {
            if !allowed_if.contains_key(iface) {
                return Err(validation_err(format!("invalid ethernets iface: {iface}"), None));
            }

            let iface_kind = match iface {
                k if k == NET_IF_INTERNAL => IfaceKind::Internal,
                k if k == NET_IF_EXTERNAL => IfaceKind::External,
                _ => unreachable!(),
            };

            entry.verify(iface, iface_kind).map_err(|e| {
                validation_err(e, Some(format!("invalid ethernets entry for '{}'", &iface)))
            })?
        }

        Ok(())
    }

    // Generators
    pub fn to_network_interfaces(&self, path: &Path, skip_internal: bool) -> Result<()> {
        let mut contents = String::new();
        contents.push_str("# Generated by lit-os (do not edit)\n");
        contents.push_str("auto lo\niface lo inet loopback\n\n");

        for iface in ALLOWED_NET_IF {
            if iface == NET_IF_INTERNAL {
                if !skip_internal {
                    // Always DHCP.
                    contents
                        .push_str(format!("auto {iface}\niface {iface} inet dhcp\n\n").as_str());
                    contents.push_str("  metric 100\n".to_string().as_str());
                }
            } else if let Some(entry) = self.ethernets.get(iface) {
                if bool_option_to_bool(entry.dhcp4.as_ref()) {
                    contents.push_str(format!("auto {iface}\niface {iface} inet dhcp\n").as_str());
                    contents.push_str("  metric 10\n\n".to_string().as_str());
                } else if bool_option_to_bool(entry.dhcp6.as_ref()) {
                    contents.push_str(format!("auto {iface}\ninet6 {iface} inet dhcp\n").as_str());
                    contents.push_str("  metric 10\n\n".to_string().as_str());
                } else if entry.have_addresses() {
                    let (have_ipv4_addr, have_ipv46_addr) = entry.verify_addresses()?;
                    let has_ipv4 = entry.verify_kind(
                        IpKind::V4,
                        &iface.to_string(),
                        IfaceKind::External,
                        entry.gateway4.as_ref(),
                        have_ipv4_addr,
                        bool_option_to_bool(entry.dhcp4.as_ref()),
                    )?;
                    let has_ipv6 = entry.verify_kind(
                        IpKind::V6,
                        &iface.to_string(),
                        IfaceKind::External,
                        entry.gateway6.as_ref(),
                        have_ipv46_addr,
                        bool_option_to_bool(entry.dhcp6.as_ref()),
                    )?;
                    let mut gw: Option<&String> = None;
                    let mut ip: Option<IpNet> = None;
                    if have_ipv4_addr && has_ipv4 {
                        let ips = entry.addresses_of(IpKind::V4)?;
                        if !ips.is_empty() {
                            gw = Some(entry.gateway4.as_ref().unwrap());
                            ip = Some(
                                IpNet::from_str(ips.first().unwrap())
                                    .map_err(|e| generic_err(e, None))?,
                            );

                            contents.push_str(
                                format!("auto {iface}\niface {iface} inet static\n").as_str(),
                            );
                        }
                    } else if have_ipv46_addr && has_ipv6 {
                        let ips = entry.addresses_of(IpKind::V4)?;
                        if !ips.is_empty() {
                            gw = Some(entry.gateway6.as_ref().unwrap());
                            ip = Some(
                                IpNet::from_str(ips.first().unwrap())
                                    .map_err(|e| generic_err(e, None))?,
                            );

                            contents.push_str(
                                format!("auto {iface}\niface6 {iface} inet static\n").as_str(),
                            );
                        }
                    }

                    if let Some(ip) = ip {
                        if let Some(gw) = gw {
                            contents.push_str("  metric 10\n".to_string().as_str());
                            contents.push_str(format!("  address {}\n", ip.addr()).as_str());
                            contents.push_str(format!("  netmask {}\n", ip.netmask()).as_str());
                            contents.push_str(format!("  gateway {gw}\n").as_str());
                            contents.push_str(
                                format!(
                                    "  post-up /usr/bin/ip route add {} dev {} src {} table pub\n",
                                    ip.trunc(),
                                    iface,
                                    ip.addr()
                                )
                                .as_str(),
                            );
                            contents.push_str(format!("  post-up /usr/bin/ip route add default via {gw} dev {iface} table pub\n").as_str());
                            contents.push_str(
                                format!("  post-up /usr/bin/ip rule add from {ip} table pub\n")
                                    .as_str(),
                            );
                            contents.push_str(
                                format!("  post-up /usr/bin/ip rule add to {ip} table pub\n\n")
                                    .as_str(),
                            );
                        }
                    }
                }
            }
        }

        fs::write(path, contents)
            .map_err(|e| io_err(e, Some(format!("failed to write file: {path:?}"))))?;

        Ok(())
    }
}

impl TryFrom<&Path> for CloudInitNetworkConfig {
    type Error = crate::error::Error;

    fn try_from(value: &Path) -> StdResult<Self, Self::Error> {
        Self::try_from(fs::read(value).map_err(|e| io_err(e, None))?)
    }
}

impl TryFrom<Vec<u8>> for CloudInitNetworkConfig {
    type Error = crate::error::Error;

    fn try_from(bytes: Vec<u8>) -> StdResult<Self, Self::Error> {
        Self::try_from(&bytes[..])
    }
}

impl TryFrom<&[u8]> for CloudInitNetworkConfig {
    type Error = crate::error::Error;

    fn try_from(bytes: &[u8]) -> StdResult<Self, Self::Error> {
        serde_yaml::from_slice(bytes).map_err(|e| serializer_err(e, None))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields, rename_all = "kebab-case")]
pub struct EthernetEntry {
    optional: Option<bool>,
    addresses: Option<Vec<String>>,
    dhcp4: Option<bool>,
    gateway4: Option<String>,
    dhcp6: Option<bool>,
    gateway6: Option<String>,
}

impl EthernetEntry {
    // Accessors
    pub fn optional(&self) -> Option<&bool> {
        self.optional.as_ref()
    }

    pub fn addresses(&self) -> Option<&Vec<String>> {
        self.addresses.as_ref()
    }

    pub fn addresses_of(&self, kind: IpKind) -> Result<Vec<String>> {
        let mut res: Vec<String> = Vec::new();

        if let Some(addresses) = self.addresses.as_ref() {
            for addr in addresses {
                if match IpNet::from_str(addr.as_str()).map_err(|e| config_err(e, None))? {
                    IpNet::V4(_) => kind == IpKind::V4,
                    IpNet::V6(_) => kind == IpKind::V6,
                } {
                    res.push(addr.clone());
                }
            }
        }

        Ok(res)
    }

    pub fn dhcp4(&self) -> Option<&bool> {
        self.dhcp4.as_ref()
    }

    pub fn gateway4(&self) -> Option<&String> {
        self.gateway4.as_ref()
    }

    pub fn dhcp6(&self) -> Option<&bool> {
        self.dhcp6.as_ref()
    }

    pub fn gateway6(&self) -> Option<&String> {
        self.gateway6.as_ref()
    }

    // Verify
    fn verify(&self, iface: &String, iface_kind: IfaceKind) -> Result<()> {
        // Verify the addresses
        let mut have_ipv4_addr = false;
        let mut have_ipv46_addr = false;
        if self.have_addresses() {
            if iface_kind == IfaceKind::Internal {
                return Err(validation_err(
                    format!("invalid config, internal iface '{iface}' must not have static IPs"),
                    None,
                ));
            }

            (have_ipv4_addr, have_ipv46_addr) = self.verify_addresses()?;
        }

        // Verify for each IP kind.
        let has_ipv4 = self.verify_kind(
            IpKind::V4,
            iface,
            iface_kind.clone(),
            self.gateway4.as_ref(),
            have_ipv4_addr,
            bool_option_to_bool(self.dhcp4.as_ref()),
        )?;
        let has_ipv6 = self.verify_kind(
            IpKind::V6,
            iface,
            iface_kind.clone(),
            self.gateway6.as_ref(),
            have_ipv46_addr,
            bool_option_to_bool(self.dhcp6.as_ref()),
        )?;

        let is_optional = bool_option_to_bool(self.optional.as_ref());

        // Validate required
        match iface_kind {
            IfaceKind::Internal => {
                if is_optional {
                    return Err(validation_err(
                        format!(
                            "invalid config, internal iface '{iface}' must not define optional"
                        ),
                        None,
                    ));
                }
                if !has_ipv4 {
                    return Err(validation_err(
                        format!("invalid config, internal iface '{iface}' no IPv4 config found"),
                        None,
                    ));
                }
                if has_ipv6 {
                    return Err(validation_err(
                        format!("invalid config, internal iface '{iface}' IPv6 config found"),
                        None,
                    ));
                }
            }
            IfaceKind::External => {
                if !is_optional && (!has_ipv4 || has_ipv6) {
                    return Err(validation_err(format!("invalid config, external iface '{iface}' not marked as optional with no config"), None));
                }
            }
        }

        Ok(())
    }

    fn verify_kind(
        &self, kind: IpKind, iface: &String, iface_kind: IfaceKind, gateway: Option<&String>,
        has_address: bool, has_dhcp: bool,
    ) -> Result<bool> {
        match iface_kind {
            IfaceKind::Internal => {
                // Internal Interface should only ever be IPv4 DHCP.
                if let Some(_gateway) = gateway {
                    return Err(validation_err(
                        format!(
                            "invalid config, internal iface '{iface}' must not have static gateway"
                        ),
                        None,
                    ));
                }

                if has_dhcp {
                    if kind == IpKind::V6 {
                        return Err(validation_err(
                            format!(
                                "invalid config, internal iface '{iface}' must not have ipv6 dhcp"
                            ),
                            None,
                        ));
                    }
                } else if kind == IpKind::V4 {
                    return Err(validation_err(
                        format!("invalid config, internal iface '{iface}' requires ipv4 dhcp"),
                        None,
                    ));
                }

                Ok(kind == IpKind::V4)
            }
            IfaceKind::External => {
                // Validate gateway
                let mut has_gateway = false;
                if let Some(gateway) = gateway {
                    let gw_ip = IpAddr::from_str(gateway.as_str()).map_err(|e| {
                        validation_err(e, Some(format!("invalid gw ip addr: {gateway}")))
                    })?;

                    match gw_ip {
                        IpAddr::V4(_) => {
                            if kind != IpKind::V4 {
                                return Err(validation_err(
                                    format!("invalid config, gateway6 is not IPv6: {gateway}"),
                                    None,
                                ));
                            }
                        }
                        IpAddr::V6(_) => {
                            if kind != IpKind::V6 {
                                return Err(validation_err(
                                    format!("invalid config, gateway4 is not IPv4: {gateway}"),
                                    None,
                                ));
                            }
                        }
                    }

                    has_gateway = true;
                }

                // Validate static
                if has_gateway || has_address {
                    if has_dhcp {
                        return Err(validation_err(
                            "invalid config, cannot mix dhcp with static".to_string(),
                            None,
                        ));
                    }

                    if !has_gateway || !has_address {
                        return Err(validation_err(
                            "invalid config, static config missing gw or ip".to_string(),
                            None,
                        ));
                    }

                    Ok(true)
                } else {
                    Ok(has_dhcp)
                }
            }
        }
    }

    fn verify_addresses(&self) -> Result<(bool, bool)> {
        let mut have_ipv4 = false;
        let mut have_ipv6 = false;

        if let Some(addresses) = self.addresses.as_ref() {
            for address in addresses.iter() {
                let addr = IpNet::from_str(address.as_str())
                    .map_err(|e| validation_err(e, Some(format!("invalid ip addr: {address}"))))?;

                match addr {
                    IpNet::V4(_) => have_ipv4 = true,
                    IpNet::V6(_) => have_ipv6 = true,
                }
            }
        }

        Ok((have_ipv4, have_ipv6))
    }

    // Accessors
    fn have_addresses(&self) -> bool {
        match self.addresses.as_ref() {
            Some(val) => !val.is_empty(),
            None => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use crate::guest::cloud_init::network_config::CloudInitNetworkConfig;

    const RESOURCES_TEST_DIR: &str = "resources/test/guest/cloud_init";

    #[test]
    fn load_ok_test() {
        let file_path = get_test_path("network-config-ok");

        let _ = CloudInitNetworkConfig::try_from(file_path.as_path())
            .expect("failed to load network-config");
    }

    #[test]
    fn load_invalid_test() {
        {
            let (test, exp_err) = ("network-config-invalid1", "unknown field `some`");
            println!("test: {test}");

            let file_path = get_test_path(test);

            let res = CloudInitNetworkConfig::try_from(file_path.as_path());

            assert!(res.is_err());

            let err = res.err().unwrap();
            if !err.to_string().contains(exp_err) {
                panic!("err does not contain '{exp_err}': {err:?}");
            }
        }
    }

    #[test]
    fn verify_ok_test() {
        let file_path = get_test_path("network-config-ok");

        let network_config = CloudInitNetworkConfig::try_from(file_path.as_path())
            .expect("failed to load network-config");

        let res = network_config.verify();
        if res.is_err() {
            panic!("failed to verify network-config: {:?}", res.err().unwrap());
        }
    }

    #[test]
    fn verify_invalid_test() {
        for (test, exp_err) in [
            (
                "network-config-invalid2",
                "invalid config, internal iface 'enp0s2' must not have ipv6 dhcp",
            ),
            (
                "network-config-invalid3",
                "invalid config, internal iface 'enp0s2' must not have static IPs",
            ),
            (
                "network-config-invalid4",
                "invalid config, internal iface 'enp0s2' must not have static gateway",
            ),
            ("network-config-invalid5", "invalid ip addr: 292.222.100.155/29"),
            ("network-config-invalid6", "invalid gw ip addr: 333.222.100.153"),
            (
                "network-config-invalid7",
                "invalid config, external iface 'enp0s3' not marked as optional with no config",
            ),
            ("network-config-invalid8", "invalid config, static config missing gw or ip"),
            ("network-config-invalid9", "invalid config, gateway6 is not IPv6: 222.222.100.15"),
            (
                "network-config-invalid10",
                "invalid config, gateway4 is not IPv4: 2345:425:2CA1:0000:0000:567:5673:23b5",
            ),
        ] {
            println!("test: {test}");

            let file_path = get_test_path(test);

            let network_config =
                CloudInitNetworkConfig::try_from(file_path.as_path()).expect("failed to load");

            let res = network_config.verify();

            assert!(res.is_err());

            let err = res.err().unwrap();
            if !err.to_string().contains(exp_err) {
                panic!("err does not contain '{exp_err}': {err:?}");
            }
        }
    }

    // Util
    fn get_test_path(path: &str) -> PathBuf {
        let mut test_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        test_path.push(RESOURCES_TEST_DIR);
        test_path.push(path);
        test_path
    }
}
